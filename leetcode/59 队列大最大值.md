#### 剑指offer 59  队列的最大值

-----

有点像之前的那个栈的最大值，都希望用很低的时间复杂度来维护一个队列的进出并知道其最大值。**核心点是当数据进出的时候，队列最大值的更新问题**

- 如果是栈的话，因为是先进后出，所以可以直接再建一个辅助列表，第i个位置上面放着的是前i个数据的最大值，这样每次弹出数据的时候直接弹出就好了。更新维护最大值也比较方便
- 但是现在是队列，先进先出，栈的这种方法就不太奏效。只能作为一个思想的辅助和参考。因为栈的话是建立一个列表存储前i个最大值，那么队列的话只能反过来存储，也就是建立一个列表，单调递增，那么该队列就维护的是原始队列最大值的一个队列。每次返回队列的第一个值的时候，同时判断该值是否等于单调队列的第一个值，如果等于的话，说明该最大值失效，因为这个单调队列是作用于该值之前的所有值。所以这样就可以起到更新维护的作用。



```python
class MaxQueue:
    #题解的意思是，建立两个队列，一个队列用于满足正常的popfront，另外一个队列保证单调性，
    def __init__(self):
        self.maxn = 0
        self.queue = []
        self.Queue = []
        self.counts = 0

    def max_value(self) -> int:
        if self.counts == 0:
            return -1
        else:
            return self.queue[0]

    def push_back(self, value: int) -> None:
        while(self.queue and value > self.queue[-1]):
            self.queue.pop()
        self.queue.append(value)
        self.Queue.append(value)
        self.counts = self.counts + 1
    def pop_front(self) -> int:
        if self.counts == 0:
            return -1
        tmp = self.Queue.pop(0)
        self.counts = self.counts - 1
        if self.queue[0] == tmp:
            self.queue.pop(0)
        return tmp




# Your MaxQueue object will be instantiated and called as such:
# obj = MaxQueue()
# param_1 = obj.max_value()
# obj.push_back(value)
# param_3 = obj.pop_front()
```

