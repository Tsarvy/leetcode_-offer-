### 剑指offer 26 树的子结构

---

因为是树的问题，又是判断一颗二叉树是否为另外一颗的子树问题，所以理所应当想到要用**递归方法**

但是这题的递归方法比较难想，

- [ ] 因为B可能是A任意一个点的子结构，所以即使当前点不满足条件，我们还需要判断left和right，观察是否可以作为子结构。
- [ ] 即使当前点满足条件，因为树B可能不仅仅包括一个点，所以我们还需要判断其儿子们是否满足条件，此处的条件也就是和A树的对应位置相同。相应的，我们需要判断其left和right，根据题意我们可以明白，要想是子结构，那么B树有的点，A树必须有，所以层层递归下去，也就是B.left要包含在A.left，B.right要包含在A.right里面才可以

所以可以知道是两重递归。

- 第一重递归，是判断当前点是否满足根节点相同的初始条件，如果满足就往下搜；同时我们知道，A树的左右儿子也可能满足，所以我们同时处理三个可能，**当前根节点，左儿子，右儿子**，这三个其中任意一个满足就可以返回True。这层递归调用的是最外层函数

- f 递归函数，用来判断树A的当前节点是否和树B的结构相等值相同，相同就继续探寻答案，不相同直接返回False，以此来判断。

~~~python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSubStructure(self, A: TreeNode, B: TreeNode) -> bool:
        def f(a,b):
            if not b: return True
            elif not a or a.val != b.val: return False
            else:
                return f(a.right,b.right) and f(a.left,b.left)
        
        return bool(A and B) and (f(A,B) or self.isSubStructure(A.left,B) or self.isSubStructure(A.right,B))
~~~

