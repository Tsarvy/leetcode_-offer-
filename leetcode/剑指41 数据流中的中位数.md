#### 41 数据流中的中位数

----

- 解法一：暴力解，也就是每次加完元素之后在排序或者找中位数的时候排序，可以过，但是肯定不是我们刷这道题的目的

- 解法二：堆/优先队列

  - 因为是求中位数，所以建立两个堆，分别是大根堆和小根堆，每一个都存储一半的数字，因为一个是大根，一个是小根，所以我们求解答案的时候只需要找到两个根顶上的数就可以了，可以极大减少时间复杂度。但是又个小问题，就是我们如果使用python的heapq模块的话，是没有大根堆只有小根堆的，我们通过取负数来对小根堆改造，这样每次我们求的结果就可以直接取负得到大根。

  - 两个堆的大小要保持一致，一个堆存放前k大的数，另外一个堆存放后面k大的数，如果此时要再加入数字进来，就加到小根堆里，存放前k+1的数。

  - 另外每次存储数据也很有道道，对大根堆的数据全部取负这个我们知道，我们存数据的时候，要把这个数据在两个根堆里都过一遍，因为我们相当于要排序，使得小根堆始终保持前k大的数，这样方便我们答案的获取。

    ```python
    from heapq import *
    class MedianFinder:
    
        def __init__(self):
            """
            initialize your data structure here.
            """
            self.num1 = []#保存大的一半，小根堆
            self.num2 = []#保存小的一半，大根堆
            self.counts = 0
    
    
        def addNum(self, num: int) -> None:
            if len(self.num1) != len(self.num2):
                heappush(self.num1,num)
                heappush(self.num2,-heappop(self.num1))
            else:
                heappush(self.num2,-num)
                heappush(self.num1,-heappop(self.num2))
            
        def findMedian(self) -> float:
            if len(self.num1) == len(self.num2):
                return (self.num1[0] - self.num2[0])/2
            else:
                return self.num1[0]
    
    
    # Your MedianFinder object will be instantiated and called as such:
    # obj = MedianFinder()
    # obj.addNum(num)
    # param_2 = obj.findMedian()
    ```

    